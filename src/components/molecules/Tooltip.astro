---
export interface Props {
  id: string;
  content: string;
  placement?: 'top' | 'bottom' | 'left' | 'right';
  trigger?: 'hover' | 'click' | 'focus';
  delay?: number;
  class?: string;
}

const {
  id,
  content,
  placement = 'top',
  trigger = 'hover',
  delay = 200,
  class: className,
  ...attrs
} = Astro.props;

const placementClasses = {
  top: 'tooltip-top',
  bottom: 'tooltip-bottom',
  left: 'tooltip-left',
  right: 'tooltip-right',
};
---

<div
  class:list={['tooltip-wrapper', className]}
  data-tooltip-id={id}
  data-tooltip-trigger={trigger}
  data-tooltip-delay={delay}
  {...attrs}
>
  <slot />
  <div
    id={id}
    class:list={['tooltip', placementClasses[placement]]}
    role="tooltip"
    aria-hidden="true"
  >
    <div class="tooltip-content">
      {content}
    </div>
    <div class="tooltip-arrow"></div>
  </div>
</div>

<style>
  .tooltip-wrapper {
    position: relative;
    display: inline-block;
  }

  .tooltip {
    position: absolute;
    z-index: var(--z-index-modal);
    padding: var(--space-xs) var(--space-sm);
    background-color: var(--color-background-primary);
    color: var(--color-text-inverse);
    border-radius: var(--radius-md);
    font-size: var(--font-size-sm);
    font-weight: var(--font-weight-regular);
    line-height: var(--line-height-tight);
    white-space: nowrap;
    opacity: 0;
    visibility: hidden;
    transform: scale(0.95);
    transition: all var(--transition-duration-base);
    pointer-events: none;
  }

  .tooltip.tooltip-visible {
    opacity: 1;
    visibility: visible;
    transform: scale(1);
  }

  .tooltip-content {
    position: relative;
    z-index: 1;
  }

  .tooltip-arrow {
    position: absolute;
    width: 0;
    height: 0;
    border: var(--space-xs) var(--border-style-solid) transparent;
  }

  /* Top placement */
  .tooltip-top {
    bottom: calc(100% + var(--space-xs));
    left: 50%;
    transform: translateX(-50%) scale(0.95);
  }

  .tooltip-top.tooltip-visible {
    transform: translateX(-50%) scale(1);
  }

  .tooltip-top .tooltip-arrow {
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    border-top-color: var(--color-background-primary);
    border-bottom: none;
  }

  /* Bottom placement */
  .tooltip-bottom {
    top: calc(100% + var(--space-xs));
    left: 50%;
    transform: translateX(-50%) scale(0.95);
  }

  .tooltip-bottom.tooltip-visible {
    transform: translateX(-50%) scale(1);
  }

  .tooltip-bottom .tooltip-arrow {
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    border-bottom-color: var(--color-background-primary);
    border-top: none;
  }

  /* Left placement */
  .tooltip-left {
    right: calc(100% + var(--space-xs));
    top: 50%;
    transform: translateY(-50%) scale(0.95);
  }

  .tooltip-left.tooltip-visible {
    transform: translateY(-50%) scale(1);
  }

  .tooltip-left .tooltip-arrow {
    left: 100%;
    top: 50%;
    transform: translateY(-50%);
    border-left-color: var(--color-background-primary);
    border-right: none;
  }

  /* Right placement */
  .tooltip-right {
    left: calc(100% + var(--space-xs));
    top: 50%;
    transform: translateY(-50%) scale(0.95);
  }

  .tooltip-right.tooltip-visible {
    transform: translateY(-50%) scale(1);
  }

  .tooltip-right .tooltip-arrow {
    right: 100%;
    top: 50%;
    transform: translateY(-50%);
    border-right-color: var(--color-background-primary);
    border-left: none;
  }

  /* Responsive adjustments */
  @media (width <= 640px) {
    .tooltip {
      max-width: calc(100vw - var(--space-lg) * 2);
      white-space: normal;
    }
  }

  /* Focus and accessibility */
  .tooltip-wrapper:focus-within .tooltip {
    opacity: 1;
    visibility: visible;
    transform: scale(1);
  }

  .tooltip-wrapper:focus-within .tooltip-top {
    transform: translateX(-50%) scale(1);
  }

  .tooltip-wrapper:focus-within .tooltip-bottom {
    transform: translateX(-50%) scale(1);
  }

  .tooltip-wrapper:focus-within .tooltip-left {
    transform: translateY(-50%) scale(1);
  }

  .tooltip-wrapper:focus-within .tooltip-right {
    transform: translateY(-50%) scale(1);
  }
</style>

<script>
  class TooltipController {
    private tooltips: Map<string, HTMLElement> = new Map();
    private timeouts: Map<string, number> = new Map();

    constructor() {
      this.init();
    }

    init() {
      // Find all tooltip wrappers
      document.querySelectorAll('[data-tooltip-id]').forEach((wrapper) => {
        const tooltipId = wrapper.getAttribute('data-tooltip-id');
        const trigger = wrapper.getAttribute('data-tooltip-trigger') || 'hover';
        const delay = parseInt(
          wrapper.getAttribute('data-tooltip-delay') || '200',
        );

        if (tooltipId) {
          const tooltip = document.getElementById(tooltipId);
          if (tooltip) {
            this.tooltips.set(tooltipId, tooltip);
            this.setupTooltip(wrapper as HTMLElement, tooltip, trigger, delay);
          }
        }
      });
    }

    setupTooltip(
      wrapper: HTMLElement,
      tooltip: HTMLElement,
      trigger: string,
      delay: number,
    ) {
      const tooltipId = tooltip.id;

      if (trigger === 'hover') {
        wrapper.addEventListener('mouseenter', () => {
          this.showTooltip(tooltipId, delay);
        });

        wrapper.addEventListener('mouseleave', () => {
          this.hideTooltip(tooltipId);
        });
      }

      if (trigger === 'click') {
        wrapper.addEventListener('click', (e) => {
          e.preventDefault();
          this.toggleTooltip(tooltipId);
        });

        // Close on outside click
        document.addEventListener('click', (e) => {
          if (!wrapper.contains(e.target as Node)) {
            this.hideTooltip(tooltipId);
          }
        });
      }

      if (trigger === 'focus') {
        const focusableElement = wrapper.querySelector(
          'button, a, input, select, textarea, [tabindex]',
        ) as HTMLElement;

        if (focusableElement) {
          focusableElement.addEventListener('focus', () => {
            this.showTooltip(tooltipId, delay);
          });

          focusableElement.addEventListener('blur', () => {
            this.hideTooltip(tooltipId);
          });
        }
      }

      // Keyboard accessibility
      wrapper.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          this.hideTooltip(tooltipId);
        }
      });
    }

    showTooltip(tooltipId: string, delay: number = 0) {
      // Clear any existing timeout
      const existingTimeout = this.timeouts.get(tooltipId);
      if (existingTimeout) {
        clearTimeout(existingTimeout);
      }

      const timeout = window.setTimeout(() => {
        const tooltip = this.tooltips.get(tooltipId);
        if (tooltip) {
          tooltip.classList.add('tooltip-visible');
          tooltip.setAttribute('aria-hidden', 'false');
        }
      }, delay);

      this.timeouts.set(tooltipId, timeout as unknown as number);
    }

    hideTooltip(tooltipId: string) {
      // Clear any existing timeout
      const existingTimeout = this.timeouts.get(tooltipId);
      if (existingTimeout) {
        clearTimeout(existingTimeout);
        this.timeouts.delete(tooltipId);
      }

      const tooltip = this.tooltips.get(tooltipId);
      if (tooltip) {
        tooltip.classList.remove('tooltip-visible');
        tooltip.setAttribute('aria-hidden', 'true');
      }
    }

    toggleTooltip(tooltipId: string) {
      const tooltip = this.tooltips.get(tooltipId);
      if (tooltip) {
        if (tooltip.classList.contains('tooltip-visible')) {
          this.hideTooltip(tooltipId);
        } else {
          this.showTooltip(tooltipId);
        }
      }
    }
  }

  // Initialize on DOM ready
  if (document.readyState === 'loading') {
    document.addEventListener(
      'DOMContentLoaded',
      () => new TooltipController(),
    );
  } else {
    new TooltipController();
  }
</script>
